pre-commit:
  parallel: true
  commands:
    go-fmt:
      glob: "*.go"
      run: test -z "$(gofmt -l . | grep -v vendor)" || (gofmt -d . && exit 1)

    go-vet:
      glob: "*.go"
      run: go vet ./...

    golangci-lint:
      glob: "*.go"
      run: golangci-lint run --timeout=5m

    go-test:
      glob: "*.go"
      run: go test -race ./...

    go-mod-tidy:
      glob: "{go.mod,go.sum,*.go}"
      run: |
        go mod tidy
        git diff --exit-code go.mod go.sum || (echo "go.mod or go.sum not tidy" && exit 1)

commit-msg:
  commands:
    semantic-commit:
      run: |
        commit_msg=$(cat {1})
        pattern="^(feat|fix|docs|chore|refactor|test|ci|perf|style|build)(\(.+\))?: .+"
        if ! echo "$commit_msg" | grep -qE "$pattern"; then
          echo "ERROR: Commit message does not follow semantic commit format"
          echo ""
          echo "Expected format: <type>(<scope>): <description>"
          echo ""
          echo "Types: feat, fix, docs, chore, refactor, test, ci, perf, style, build"
          echo ""
          echo "Examples:"
          echo "  feat(core): add move transformation"
          echo "  fix(git): handle empty commits"
          echo "  docs: update README"
          echo ""
          echo "Your message: $commit_msg"
          exit 1
        fi

pre-push:
  parallel: true
  commands:
    go-build:
      run: go build ./...

    go-build-wasm:
      run: GOOS=js GOARCH=wasm go build -o /dev/null ./wasm/

    go-test-full:
      run: go test -race -coverprofile=coverage.out ./...
